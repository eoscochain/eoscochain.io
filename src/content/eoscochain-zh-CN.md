# EOS Cochain

**A parallel EOS blockchain for inter-chain communication network**

**构建跨链通信网络的EOS并行链**

[[toc]]

## 背景
[比特币][1]自2009年诞生以来,作为一种电子现金货币已经成为社会现象级话题，开创了去中心化加密货币的先河，其底层技术区块链更是不断被人们所研究。作为区块链2.0的[以太坊][2]则摆脱了数字货币的枷锁，以太坊创造性的提出了“可编程区块链”，使其成为分布式应用开发的平台，带来了深远的影响。以加密著称的[零币][3]和[门罗币][4]同样取得成功。自比特币诞生近10年以来，数以千计的区块链项目被开发出来，有的项目从商业落地角度出发，希望借助区块链的特性寻求一些商业场景，也有的项目从解决区块链性能问题出发，希望开发性能更可靠、可用性更强的区块链。但是目前大多数区块链项目仍然因为区块链技术架构限制面临着诸多难题，如区块容量扩展性和伸缩性、缺乏链上治理、分布式共识性能瓶颈等。我们认为这些问题不仅存在于某一条区块链，也不仅局限于某一种应用场景上，所以我们在研究和尝试解决这些问题的时候，发现诸多问题不是单一区块链能彻底解决的，而是应该探索系统化的多链解决方案，让各种同构或异构区块链能够互联互通，取长补短，价值互换。于是我们发现，跨链技术的设计和实现，是解决区块链诸多问题的关键。不论对于公有链还是联盟链，跨链技术都是实现价值互联网的关键，它是把区块链从分散的价值孤岛中拯救出来的良药，是区块链向外延展和互联的桥梁，能进一步拓宽区块链技术的应用范围。


## EOS概述
[EOS][5]是[Block.One公司][6]研发的一个区块链底层公链系统，目的是解决现有的区块链应用性能低、安全性差、开发难度高以及过度依赖手续费的问题，实现分布式应用的性能扩展。EOS提供帐户，身份验证，数据库，异步通信以及在数以百计的CPU或集群上的程序调度，每秒可以支持百万个交易，同时普通用户无需支付使用费用。

<!--EOS的主要特点如下：-->

<!--- **交易成本**：以太坊网络中，交易转账、存储、操作，开发和部署智能合约，都需要消耗gas费用，在EOS上转账交易与运行智能合约并不需要消耗EOS系统代币。在EOS系统当中，有三大类资源被应用程序消耗：带宽和日志存储（磁盘），计算算力(CPU)，以及状态存储器（RAM），这些资源根据账户持有EOS数量来分配，这也是EOS系统代币的价值来源。-->
<!--- **可扩展性**：现有的区块链技术面临的最大问题就是扩容性，比特币每秒处理交易7笔左右，以太坊每秒处理15笔左右。基于DPOS共识算法和石墨烯底层技术的EOS在较苛刻的测试条件下单线程可以达到每秒1000次交易，在较为理想的状态下多线程能达上万笔，EOS宣称的百万级tps最终是通过并行链的并行处理方式，可以使交易规模达到每秒几百万次，传统的支付手段例如Visa，每秒可以转账1667次，百万级tps的EOS是完全满足的。支持多链并行和跨链的EOS，正体现了其作为底层公链的可拓展性方面，而并行链也是完善EOS生态的重要一环。-->

作为下一代公链的代表性项目，EOS已经于2018年6月份在社区成员的共同努力下成功启动了主网，吸引了区块链行业内外的广泛关注。我们认为，随着Block.one开发团队在EOSIO软件开发上的持续努力，以及超级节点们在主网运维和安全上的经验积累，EOS主网在2018年年底前将逐渐稳定，并迎来DAPP爆发期。然而，即使当前超级节点都配备了顶级硬件，受限于单线程执行模型和非[JIT][7]的WebAssembly虚拟机，EOS主网TPS在**几百到一千左右**。我们很早就注意到，EOS.IO白皮书摘要中宣称EOS.IO软件引入的全新区块链架构设计，能够通过**纵向**和**横向**扩展，最终达到**百万级TPS**。纵向扩展，包括不断升级硬件性能、引入多线程执行模型和JIT使能的WebAssembly虚拟机，我们相信将使TPS推高到**一万**左右。我们认为，只有通过横向扩展，即采用多链并行的方式，EOS才有可能达到百万TPS，而那时，我们所看到的EOS已经不是单一的一条主网区块链，而是无数个使用EOSIO软件的多链并行的EOS同构跨链群体系。

## EOS Cochain概述

EOS Cochain正是要做EOS同构跨链群里的第一条与EOS主网跨链通信的并行链，我们不断的在探索和尝试开发跨链技术，最终发现，跨链技术并不需要先从异构跨链直接做起，首先对支持对跨链友好的区块链，我们就可以直接采用通过构建区块链并行链的方式，进行跨链交互。这么做是很有必要的，可以说未来可能有很多公链运行在开放网络中，也会有很多联盟链、私有链运行在企业、联盟的内部网络中，这些区块链之间并不需要全部是异构的形态，除了必要的业务应用层不同之外，这些底层区块链结构可能都会是相同的，那么我们就有必要先从同构链开始进行跨链研究。我们相信，通过开发第一条与EOS跨链通信的并行链，我们能达到的效果是，让EOS区块链落地各大商业场景，这些使用EOS区块链的机构、企业和联盟，可以通过我们的同构跨链协议随时与EOS主网和其他企业EOS并行链进行访问和连接，也可以支持大型的DAPP把功能分开解耦到各平行链中，这样不管从EOS区块链的发展还是DAPP的发展，我们不仅要让EOS区块链遍地开花，更要推动大型DAPP在区块链上能真正落地！

EOS Cochain将成为EOS主链的第一条协作并行链，将在EOS.IO软件基础上进行系统功能定制、插件开发、合约部署，邀请社区成员广泛参与竞选超级节点，维护并行链运行。EOS Cochain将尊崇EOS宪法精神并考虑EOS ICO投资人的利益分配和投票权，但在系统参数上将稍微有别于EOS主链，以支持同构跨链和更远将来的异构跨链。
EOS Cochain以横向扩展EOS全网性能为目标，引入全新的同构跨链通信模型，设计安全性好、链间性能高的同构跨链协议，与EOS主链协调一致、相互感知地共同工作，始终维持一致的EOS网络全局状态视图。在可以预见的未来，更多的并行链可以使用EOS Cochain的同构跨链协议加入EOS生态体系，近乎无限地横向扩展EOS网络。

作为一条能与EOS进行跨链的并行链，EOS Cochain既补充和促进EOS生态体系建设与发展，又能与其他区块链网络打通数据交互，构建出一个相互连接、多维度数据相互关联的网络世界。运行在EOS Cochain上的DAPP也可以选择通过跨链通信，运行在EOS的区块链上，EOS上的DAPP同样可以运行在EOS Cochain上，通过跨链的价值交换协议，实现多链并行的网络，可以更好地将EOS社区共识、个体行为、价值交换有机地整合在一起，以满足不同的应用场景。

多链并行，之所以目前不被社区过多提及，是因为技术实现上的巨大难度。维护几条独立运行的区块链网络，可能仅仅是基础设施和人力投入的倍数复制。而要使这些链相互之间能够去中心化安全可靠地持续互操作，构建多链系统的全局一致性状态视图，就必须设计与区块链底层机制协作的跨链通信模型。值得一提的是，EOS.IO软件层面，已经考虑到了跨链友好性，包括轻客户端验证的[Merkle证明][8]、跨链延迟和最终性、完备性证明、隔离见证。我们通过对跨链设计友好的EOS区块链进行设计开发，通过对跨链通信协议的基础研究，一步步展示EOS Cochian的设计过程与原理。

## 跨链通信协议研究

### 跨链通信可行性研究
可行性证明：
跨链技术需要其技术服务可实现跨区块链间互联互通，链上资产在链间共识和同步的基础上可达成原子交换，在链外资产仍具备链上属性，如可权益证明，可跨链执行合约。

为实现以上跨链技术所要求的功能，我们不仅只要求区块链间只需要单向或双向的锁定交易哈希以证明资产操作为目的，需要把跨链技术作为一项区块链技术的基础技术服务和协议去研究，让跨链技术不仅服务于链上资产证明，更要让跨链技术推进区块链连接性、伸缩性、扩展性，使跨链技术作为推进区块链项目落地的一种必要手段。

从实现跨链机制的角度来看，为了实现跨区块链间通信，资产转移，跨链执行合约，我们需要做的工作有，链间可通信方式，例如使用合约创建链间通信协议包，使用合约作为解析器可中继协议包，直接设计跨链友好的可支持协议包创建和中继的区块链系统；链上资产转移，例如通过设计跨链区块链直接支持其他链上状态机查询和区块链头验证，通过使用合约可以创建、锁定和销毁链上资产；跨链执行合约，例如通过设计可支持跨链验证和执行合约的虚拟机。

实现路径：以上证明区块链间通信和资产转移的可行性，下面我们分析通过那些路径可实现以上跨链技术的链交互方式。

* 1.链A需要构造一笔跨链交易/执行链B合约请求
* 2.这笔跨链交易需要被中继转发到链B
* 3.链B需要验证交易合法性/请求合法性并回执给链A
* 4.链B存储这一笔跨链交易

### 跨链通信协议设计

我们现在根据链间通信的场景来讨论设计和如何实现链间通信的方法。
现在我们有一条自己的支持跨链通信的区块链（EOS Cochain），这条区块链需要和另外一条如以太坊区块链进行通信，按以上实现路径我们需要设计和使用那些功能和数据结构。

首先我们需要设计一种跨链交易协议ICP（Inter-Chain Protocol），ICP协议使用跨链消息传递模型，不对网络同步做任何假设，即先不考虑网络问题。协议需要能构造跨区块链间链交易和请求中继者从一个区块链中继另一个区块链。链A和链B需独立地确认新块，并且从一个链到另一个链的协议包可以被任意延迟或检查。协议包传输和确认的速度仅受各区块链本身速度的限制。

这里定义的ICP协议不感知载荷。链B上的协议包接收者根据接收到的信息决定如何采取行动，并根据协议包包含的数据可以添加其自己的应用逻辑来确定要改变哪些状态事务。

为了促进有效的ICP协议传输和确认，我们引入了一个ICP通道：一组可靠的消息队列，可以保证ICP数据包的跨链因果排序。因果排序意味着如果数据包x在链A上的数据包y之前被处理，则数据包x也必须在链B上的数据包y之前被处理。

ICP通道在两条区块链间实现了一个分布式向量时钟去添加两条链处理消息的约束条件，保证链间的每一笔交易都具有明确的因果关系和时序性，这样就不会因为网络延时、链间共识不同而存在状态不明确问题。

向量时钟:

>1. 如果事件a和事件b是同一个进程中的并且事件a发生在事件b前面，那么a->b
>2. 如果进程A发送一条消息m给进程B，a代表进程A发送消息m的事件，b代表进程B接收消息m的事件，那么a->b(由于消息的传递需要时间)


```
A:send(msgi ) → B:receive(msgi )

B:receive(msgi ) → A:receipt(msgi )

A:send(msgi ) → A:send(msgi+1 )

x → A:send(msgi ) ⇒ x → B:receive(msgi )

y → B:receive(msgi ) ⇒ y → A:receipt(msgi )
```


<img src="https://github.com/zhouyasong/images/raw/master/vector-clock.png" width=300 height=300 />

例如，跨链协议可能希望允许单个标记化资产在多个区块链之间进行传输并保留，同时保持可用性和节约资源。当一个特定的ICP数据包被提交给链B时，链B接收数据包并创建资产凭证，并要求链A再发送一份确认B上资产凭证已生成的回执证明。

### 跨链通信协议结构设计

下面我们具体详细讨论我们使用ICP协议完成跨链通信过程中所设计的协议包和相关功能的数据结构。
我们需要定义两种ICP协议包，第一种可以生成跨链交易的数据包，第二种可以验证两台链的状态机的回执数据包。

#####  1.交易数据包（ICP tx）
目前交易数据包里需要包含五个原子集数据。

* **路由信息 (route)** 路由信息里包含了链间中继者需要解析并中继的路由字段
* **序列号 (sequence)** 序列号是一个无符号的任意精度整数
* **发送方信息 (sender)** 唯一标示发送者的链、链接、链间通道的字符串
* **交易数据 (tx data)** 交易方的交易和链上证明
* **接收方信息（receiver）** 唯一标示接收者的链、链接、链间通道的字符串

##### 2.回执数据包
回执数据包需要包含五个原子集信息。

* **路由信息 (route)** 路由信息里包含了链间中继者需要解析并中继的路由字段
* **序列号 (sequence)**  序列号是一个无符号的任意精度整数
* **发送方信息 (sender)** 唯一标示发送者的链、链接、链间通道的字符串
* **接收方信息 (receiver)** 唯一标示接收者的链、链接、链间通道的字符串
* **返回结果 (result)** 接收方接收处理证明

##### 3.链间信道
为了实现严格的交易消息排序处理方式，我们还需要引入[消息队列][9]，需要实现以下队列操作：

ICP链间信道促进两个区块链A和B之间的有序双向通信。ICP链间通道可以具有任意数量的关联信道，但是ICP链间通道需要独立处理自己队列头部初始化和更新等操作。

* **outgoing_A**: 从链A发送到链B上的ICP交易数据包，存储在链A上
* **incoming_A**: 从链B发送出来的ICP回执数据包，存储在链A上
* **outgoing_B**: 从链B发送到链A上的ICP交易数据包，存储在链B上
* **incoming_B**: 从链A发送出来的ICP回执数据包，存储在链B上

<img src="https://github.com/zhouyasong/images/raw/master/channel.png" style="height: 350px" />


### 跨链通信结构体系分类

##### 同构跨链

EOS Cochain作为EOS主链的并行链，将EOSIO软件作为区块链底层基础设施，虽略作修改，但依然保持同样的BFT-DPOS共识机制和区块链数据结构。因此其与EOS主链之间的跨链，属于同构跨链。同构跨链的难度在于必须深刻理解其同构链的底层机制，并在不影响保持主链*独立性*的前提下，通过编写插件和智能合约来实现同构跨链协议包的传输、解析、处理。

##### 异构跨链

EOS Cochain更远期的目标是，接入Cochain跨链生态，实现与各主流公链的互联互通，包括比特币、以太坊、[Cosmos][10]、[Polkadot][11]、[Filecoin][12]等，也通过Eos Cochain可以实现EOS同构跨链体系与外界各公链的互联互通。显而易见，这种异构跨链，由于要考虑不同的区块链的机制细节的差异，难度比同构跨链高得多。

根据以上跨链研究分析，异构跨链间的互联互通，将可能采用中继链、区域链、平行链等的方式进行探索研究，以研究现有的异构链跨链技术为研究落脚点，如Cosmos、Polkadot，通过实现特定的平行链、区域链与各公链、联盟链、私有链进行跨链交互，通过对这些跨链技术进行深入的研究和升级，
独立探索出一种更安全、扩展性更强、链间通信性能更强的跨链技术。

基于对异构跨链的设计和研究，针对EOS Cochain链，我们将会设计这样一个类似于区域链EOS Zone，实现它们之间的跨链通信。从而，EOS主链和其同构跨链体系将通过EOS Cochain并行链和EOS Zone区域链，与Cochain中心链互联。这样以Cochain中心链为中心的跨链体系，可实现最广泛的公链们的互联互通、价值流动、资源互操作。

## EOS Cochain 设计与实现方式
通过以上对区块链间通信协议的深入研究，我们定义了同构跨链与异构跨链两个概念，并将EOS Cochain分类到同构跨链体系的范畴进行研究和开发。

EOS Cochain并行链与EOS主链之间的同构跨链，涉及以下组件：
- 同构跨链协议（Isomorphic Inter-Chain Protocol, ICP）
- 同构跨链合约，在并行链和主链上同时部署，支持跨链协议包的解析，证明的验证和存储，以及EOS原生币（EOS）、EOS Cochain原生币（EOC）、EOS代币的跨链资产转移
- 同构跨链通道，通过逻辑证明确保通道建立的稳定性和安全性。
- 中继者，将跨链协议包在并行链和主链之间安全快速地传输

EOS Cochain在不远的将来，还将参与到Cochain异构跨链生态中，作为连接EOS主链和异构跨链网络的桥梁。Cochain异构跨链网络，将广泛容纳和连接全球最前沿主流公链，使得形态各异、应用场景千差万别的异构链之间的直接通信成为可能，构建多链高速公路网络。EOS Cochain也将因为这样纽带性的角色地位，不仅大大提升自身价值，也促成EOS生态和其他公链生态的紧密融合与协作。

EOS Cochain并行链采用EOSIO软件，做若干系统参数修改或功能增强，与EOS主链将**有且仅有**如下提及的差异，除此之外，拥有EOS主链的其他所有特性或功能，包括BFT-DPOS共识算法、基于权限控制的命名账户体系、智能合约等。

### 同构跨链协议（Isomorphic Inter-Chain Protocol, ICP）

跨链协议是为了能够表达去中心化的跨链互操作过程中的状态转换。同构跨链协议仅需要考虑同构的链之间的互操作，是一种对称、双向的协议。基于尽量避免改动EOSIO软件底层设施的出发点，我们将实现同时部署到两条同构链上的跨链合约。因此，同构跨链协议被设计为包含状态数据和区块证明的数据包，由中继者执行链与链的数据包中继，也即调用跨链合约的接口。

协议数据包的设计，需要考虑：
- 可证明性：被中继的数据包必须在来源链上写入区块，并通过Merkle证明来表达其不可篡改，使得目标链可以安全地将它作为依据来执行状态转换。
- 最终性：一个数据包被中继到目标链并生效时，其来源链的相关区块必须已被确认、不可逆，否则跨链共识失败。
- 全局顺序唯一性：确保数据包的因果顺序，且避免重放攻击。
- 中继幂等性：多个中继者可能重复中继同一个数据包，必须保证只有第一次中继生效，后续中继均不产生任何效果。
- 超时可控性：由于网络通信延迟或拥堵、中继者不及时中继或因故障暂停中继，总会不可避免地造成数据包的中继延迟，这时需要超时机制来表达跨链交易发起方对于瞬时成功或失败的诉求。

我们设计用于EOS Chain并行链和EOS主链的两种跨链协议包：ICPBlockHeader和ICPTx。

ICPBlock是用于一条链同步跟踪另一条链的区块（头）的跨链协议包，形成跨链交易的安全证明链条：
```C++
struct block_header {
    block_timestamp_type timestamp;
    account_name producer;
    uint16_t confirmed;  
    block_id_type previous;
    checksum256_type transaction_mroot;
    checksum256_type action_mroot; // action的Merkle树根
    uint32_t schedule_version;
    optional<producer_schedule_type> new_producers;
    extensions_type header_extensions;
}

struct ICPBlockHeader {
    block_header header; // 区块头
    incremental_merkle blockroot_merkle; // 区块ID的Merkle树
    digest_type pending_schedule_hash; // 生产者集合的哈希
    signature_type producer_signature; // 本区块的生产者签名
}
```

ICPTx是跨链交易协议包，包含跨链交易的有效载荷数据，并包含到区块头的Merkle证明：
```C++
struct action {
    account_name account;
    action_name name;
    vector<permission_level> authorization;
    bytes data; // 跨链交易的载荷数据
}

struct action_receipt {
    account_name receiver;
    digest_type act_digest; // action的哈希
    uint64_t global_sequence;
    uint64_t recv_sequence;
    flat_map<account_name,uint64_t> auth_sequence;
    fc::unsigned_int code_sequence;
    fc::unsigned_int abi_sequence;
}

struct ICPTx {
    digest_type block_id; // action所在的区块头
    action_receipt action;
    vector<digest_type> action_merkle_proof; // action的Merkle证明
}
```

### 跨链合约

跨链合约同时部署在EOS Cochain并行链和EOS主链上，合约账户名同为`cochaintoeos`，处理双向的交易action，提供如下接口：
- `postblock`: 提交发送链的区块（头）
- `posttx`: 提交发送链的跨链交易
- `call`: 提交去往目标链的跨链交易

用户或应用调用`call`发起跨链交易，中继者监听到后调用`postblock`提交`ICPBlockHeader`，调用`posttx`提交`ICPTx`。前者是调用发送链跨链合约，后者是目标链跨链合约。

跨链最具代表性的应用是跨链资产转移，下面举例。

**从EOS主链到EOS Cochain并行链**

1. Alice发送一笔10个EOS的交易给EOS主链的跨链合约，接收账户是Alice在EOS Cochain并行链上的账户。
2. 中继者监听到了这笔资产转移交易，等待这笔交易所在的区块已被确认后，包装成跨链协议包，发送给EOS Cochain上的跨链合约。
3. Alice在EOS Cochain上的账户收到了10个CEOS代币（EOS在EOS COchain的表示法）。
4. Alice在EOS Cochain上发送了4个CEOS代币给Bob。
5. Bob发送4个CEOS的交易到EOS Cochain的跨链合约，接收账户是Bob在EOS主链上的账户。
6. 中继者监听到了这笔赎回交易，等待这笔交易所在的区块被确认后，包装成跨链协议包，发送给EOS主链上的跨链合约，跨链合约处理后将4个EOS释放给Bob。

以上流程结束后，Alice拥有6个CEOS，Bob拥有4个EOS。

类似的，从EOS Cochain并行链到EOS主链，也是相似的流程。

### 跨链通道

跨链最基本的前提在于，能够验证B链收到的跨链协议包确实是A链产生的，并且与之相关的逻辑已经在A链上执行了（比如资产转移时锁定一方资产），那么可以安全地在B链上执行后续的应用逻辑（比如产生另一方的等值资产）。我们设想了**跨链通道**这一抽象概念来保障这个基本前提。

**开启通道**

两条链建立跨链通道，必须基于某个**信任种子**，后续的证明都可追溯到这个信任种子。对于一条链来说，信任种子可以是另一条链的创世块，也可以是另一条链的任何已确认的签名区块头。这个选择，可以由链上治理来达成共识。从A链信任种子开始，B链可以验证任何后续A链的区块头的有效性，并且必须验证签名的超级节点集合是否正确。EOS的超级节点集合是随着持续的投票进程而动态变化的，那么也得验证每一次节点的变动是否体现在区块头中。

EOS区块头中超级节点集合及其变动版本号：
```
struct block_header {
    ...
    uint32_t schedule_version;
    optional<producer_schedule_type> new_producers;
    ...
}
```

这保证了基于信任种子的持续验证的内在一致性和可审计性，但如果发生分叉攻击，那么就必须再次通过链上治理来校正。

**通道运转**

通道的持续运转，体现在一条链跟随另一条链的区块头一直前进，也即从区块头`H_g`到区块头`H_h`，其中`h > g`。如果不要求`h = n + 1`，则意味着不需要区块头的连续跟随。BFT-DPOS共识机制下，只要被考察的两个区块头所代表的区段内，超级节点集合的变动少于三分之一，则能保证跟随的安全性。

**关闭通道**

两条链之间的跨链通道，正常情况下永远不应该关闭。但在遇到不可解决的极端情境下（比如[拜占庭错误][13]），可以通过链上治理或另一条链上的超级节点的签名集来关闭通道。这时，需要保障用户资产的重新赎回。

### 中继者

加持了跨链合约的EOS区块链，自身可以表达和记录跨链的*意图*，但不能也不会主动发起跨链通信，只能被动接受外部调用其跨链合约的接口。我们将实现**中继者**，作为EOSIO软件的插件，可同时部署在EOS Cochain并行链全节点和EOS主链全节点中。中继者负责在EOS和EOS Chain链间实时同步双向ICP包。

中继算法：
```
while true
    set pending = tail(outgoing_A)
    set received = tail(incoming_B)
    if pending > received
        set U_h = A.latestHeader # 获取A链的最新区块头
        if U_h != B.knownHeaderA
            B.updateHeader(U_h) # B链同步A链的最新区块头
        for i from received to pending # 遍历未处理的ICP包
            set P = outgoing_A[i] # 获取ICP中的载荷数据
            set M_kvh = A.prove(U_h, P) # 获取A链的Merkle证明
            B.receive(P, M_kvh) # 发送交易给B链，触发合约动作
```

中继最新区块头，相比于发送跨链交易，开销大得多。因此中继者可以等待足够多的未处理ICP包，然后一次性处理，这样相当于多笔跨链交易对应一次区块头同步。这将大大减少目标链上的计算开销，但也带来了跨链交易的延迟，中继者可以根据实际情况折中动态调整。    

我们设计中继过程是完全异步的、无需实时的、幂等的，却必须保证有序、可证明、超时可控。因此采用上文所述的跨链消息队列，在链上缓存跨链交易协议包。消息队列的数据结构内建在跨链合约中，队列中元素存储于区块链状态数据库。

### 系统参数定制

- 每个EOC最多只能投票**3个**超级节点，而不是30个
- 投票用户参与节点奖励分红，由宪法规定分红比例

### 系统插件

- MySQL插件，可被区块链浏览器或钱包开发者用于历史数据的存储和并发查询
- 水龙头插件，可被节点启用以为用户自动创建账户

### 系统合约

- Token合约：支持由跨链合约内联调用注册新的Token
- CrowdSale众筹合约：支持调用Token合约
- NameAuction名字竞价合约：顶级名字和次级名字的竞价

### 协同治理

EOS Cochain尊重EOS主链的宪法，但也拥有自己的宪法。当EOS社区进行宪法修正提案投票时，如果最后实施的链上变更将影响EOS Cochain与EOS的互操作，EOS Cochain应当同时发起与之适配的宪法修正提案，并在恰当的时刻将适配变更同步实施到EOS Cochain并行链上。考虑最坏情况下，EOS Cochain宪法与EOS宪法的同步修订不能取得社区的一致性意见，后果将是跨链不能正常工作，那么预计很大一部分社区成员是同时持有两个链的原生Token，为了保障自己的利益，将会努力促成跨链功能的恢复，因而在宪法修订上**最终**将达成共识。

EOS Cochain链上治理，将采取有别于EOS主链的提案投票方式：
1. 全网EOC持有者投反对票，如果一月内投票数超过总数的三分之二，提案不通过，否则
2. 超级节点投赞成票，如果一月内超过总数的三分之二，提案通过，否则
3. 提案不通过

链上治理的结果很多时候将影响EOS Cochain的系统机制，涉及到每一个EOC持有者的权益。第一阶段给予全网EOC持有者投反对票的权力，是为了既避免超级节点联盟或合谋的中心化危害，又调动EOC持有者参与链上治理的积极性。但全网投票，很难达到总数的三分之二，这也表明社区的反对意见不足以直接推翻提案，所以第二阶段继续由超级节点投票，加速提案表决。

## 应用场景

### EOS同构跨链群体系

区块链世界不可能由一条区块链主导，一定是多商业场景分布式应用、多链并存的世界。EOS多链并行的扩展模式的架构也是为了承载更多商业应用，如果使用主链来承载所有业务，除了硬件成本昂贵，还非常不利于商业对接。采用“主链+并行链”多链并行的扩展机制。这种机制分离了主链和并行链，由不同的并行链来承载各类商业业务，降低参与门槛，同时满足百万级 TPS 需求。并行链业务链可随业务复杂度继续平行扩展，承载交易量指数级上升。EOS Cochain做为第一条并行链，将通过提供跨链技术服务支持，提供并行链解决方案，打造EOS同构跨链群体系！

### 异构跨链连接
我们相信未来的区块链不仅在去中心化社区中得到商业落地前景，千万中小企业同样需要区块链作为价值传递的基础服务，未来不仅是公有链、联盟链还是企业内部的私有链，都需要一个在一个公用网络中进行价值传递和证明。
作为第一条EOS同构并行链，我们将在开发EOS Cochain的基础上，继续探索和研究异构链的跨链协议，不仅要为EOS生态做出支持百万tps的并行链体系，更要为整个EOS体系连接异构链做出创造性的贡献，作为连接EOS主链及整个EOS跨链群体系与其他区块链链的纽带，为所有异构区块链公链、联盟链、私有链实现安全、快捷、无限扩展的区块链生态体系！
### Cochain 钱包
Cochian钱包是EOS跨链群体系的关键入口，是一个多币种跨链钱包，目的为垂直进入EOS跨链群体系，作为EOS生态跨链群体系的生态入口，提供跨链转账，跨链资产兑换，跨链DAPP的应用平台。未来，Cochain钱包将继续支持异构链跨链体系，作为区块链万链互联的应用平台入口。

### 分布式交易所
随着数字资产的规模和种类不断增加，各类代币间的交易需求水涨船高。伴随着数以千计的新代币的出现，包括传统资产的代币化，这⼀需求又被放⼤了。当前市面上的交易所大部分都是中心化的。特点主要就是能够提升效率和方便，但同时面临以下三大问题：
- **缺乏安全性**：中心化的交易所⽤户常常都是把⾃⼰的私钥（资⾦）交给⼀个中⼼化的实体来管理，这使得交易所很容易成为黑客攻击的对象，数字资产的交易本身对安全性要求非常高，能做到满足安全性能要求的交易所也很少。
- **缺乏透明性**：交易所占据着大量用户资产，在监管缺失的环境中，利用暗箱操作手段攫取用户利益屡见不鲜，同时中心化交易所还面临着不确定的政策监管问题。
- **缺乏流动性**：中心化交易所之间订单订单需求无法共享，难以提供充分的流动性和交易深度。这不但会影响用户体验，还会大大增加用户的交易成本。

因此，⽆需信任的代币（价值）交易自然成为了区块链技术⼀个令人期待的使用场景。EOSCochain作为一条底层公链，具备了建立一个分布式交易所的条件，链上处理资金的保管和结算，链下集中订单撮合，以获得令人满意的用户体验和深度订单。EOSCochain的快速交易执行是另一大优势，空间可以在不牺牲一致性的前提下，通过优先完善快速交易，来实现交易的快速完成——针对双向订单交易，及IBC（跨区块链通信）代币与其他空间的交易。其交易吞吐能力及提交延时情况可以和中心化交易所媲美。交易者可以在离线的状态下提交限价订单。并且，在Zone以及IBC的应用下，交易者可以快速地完成资金在交易所及其他空间的转出转入。

### 跨链DAPP
DAPP的发展一直受区块链性能的影响并没有给区块链用户一个很好的服务体验，当大型的DAPP把功能解耦开来分散到各并行链或其他区块链上实现，通过跨链协议进行连接，通过跨链的代币转移可以享受到多条链上的数据服务，我们认为这才是区块链DAPP正确的开发和使用方式。

## EOS Cochain 的经济模型
### EOC代币
所有的区块链都是资源受限的，并且需要一个系统来防止滥用。EOS Cochain系统中有自己的代币，既EOC。EOC是系统中唯一的权益代币，用于所有交易的价值载体以及支付使用资源的佣金费用。

### EOS ICO投资人的EOC映射

EOC的总量为11亿枚，在eoc 主网上线并能与eos网络进行跨链互联时，我们将以10:1的比例分发给EOS ICO投资人1亿枚，作为eoc 与eos网络之间第一笔跨链交易转账。 考虑到EOS私钥安全性，我们将提供EOC映射合约，允许EOS快照中的EOS投资人向此合约发送自己在EOS Cochain并行链上账户的公钥，也即每个投资人使用新的私钥，来管控EOC资产，不需要使用EOS主链上的账户的私钥。


### 代币分配
除去为eos生态做贡献和回馈给eos生态参与者的1亿枚eoc。我们还有10枚eoc。

EOS Cochain的初始代币分配方案和实施细则如下：

1. 25%由eos cochain基金会持有，由网络维护者和代币持有者投票决定用于基于EOS Cochain的优质项目建设、开发和eos cochain社区商务合作，用于为基金会正常运营和管理支出。
2. 35%用于运营推广和社区生态建设，回馈给参与社区运营者和为社区建设作出贡献者。
3. 20%分配给早期投资者，投资者社区是EOS Cochain的坚定支持者，初始代币锁仓，EOS Cochain主网上线后按比例线性释放。募集到的资金将全部用于EOS Cochain的研发工作和社区建设工作。
4. 20% 用于奖励给EOS Cochain代码贡献者，由cochain持有，代币分配初始锁定，EOS Cochain上线后按每月百分之五比例线性释放。


<img src="https://github.com/zhouyasong/images/raw/master/token.png" width=400 height=300 />


### 网络维护及节点奖励机制
和eos主网一样，EOS Cochain也会为网络维护者及超级节点进行代币的奖励，为系统经济和网络维护设计一种温和通胀机制，通胀率为每年不到百分之5，其中分配细则如下：
1. 通胀EOC的50%, 用于给参与网络维护节点的奖励，包括出块节点和备选节点。
2. 通胀EOC的50%，按比例奖励给节点投票人。

## EOS Cochain发展路线规划
（一）、第一阶段 (7-12月）

上线测试网络，进行安全性检查和测试。完善技术开发文档，修改EOS Cochain主要的系统参数，开发必要的系统插件，完善EOS Cochain系统功能，开发钱包、区块链浏览器等，上线eos cochain主网。

（二）、第二阶段 （19.1月-19.5月）

建设EOS Cochain生态开发，完成与eos主网跨链互联，建立开发者社区，推进开发者进入EOS Cochain生态建设工作，开发跨链DAPP。

（三）、第三阶段 （19.5月- ）

完善跨链协议，开发统一协议规范，集成开发环境，帮助eos生态完成各大并行链开发对接工作。

## 相关工作

### Cosmos

Cosmos是构建EOS Cochain并行链的最初想法来源，它是第一个将异构跨链技术系统化并在代码上付诸卓有成效的实现的公链项目。其采用[Tendermint][14] 共识底层，通过ABCI进行上层模块开发，提出Hub和Zone等清晰一致的跨链模型，并实现了一个连接以太坊的Peggy Zone的原型。然而，Cosmos从始至终都将以太坊作为跨链的首要目标，无暇参与贡献EOS生态。并且Cosmos选择了模块化机制来进行功能扩展，目前没有内建智能合约虚拟机的计划。

### 以太坊分片

以太坊分片技术，是解决区块链扩展性的另一种新颖方法。以太坊基金会和社区在这项技术上的探索已经很久，但需要硬分叉以太坊，且落地日期依然遥遥无期。而EOS Cochain务实地选用多链并行和跨链协议的方式来达成横向扩展，对EOS主链没有侵入性，且实现上安全可靠。

### Polkadot

Polkadot是另一种解决异构跨链难题的公链项目，它设计了4种角色（收集人、钓鱼人、提名人、验证人）和2种链（中继链、平行链，类似于Cosmos的Hub和Zone），且对中继链的验证人进行分组，每个组中的验证人必须同时参与对应的平行链的验证。这带来了很高的复杂度和耦合性，平行链的独立性受到很大制约。

## 总结

EOSCochain秉承构建区块链互通互联的使命，打造EOS跨链通信网络体系，同时致力于扩展区块链生态体系，推动人类经济和人类社会体系结构的发展和进步。

## 鸣谢
感谢一同参与这项研究工作的贡献者，特别感谢跨链科技的各位合作伙伴，这项工作没有他们的参与不可能研究这么深入。除此之外，我们感恩自己在走上探索跨链之路时就已经有前人给我们指明了路标，尤其感谢cosmos 和 polkadot等正在为区块链探索跨链技术的团队！

## 引用

* 1.bitcoin: https://bitcoin.org/bitcoin.pdf
* 2.ethereum: https://github.com/ethereum/wiki/wiki/White-Paper
* 3.zero-cash: http://zerocash-project.org/paper
* 4.monero: https://getmonero.org/
* 5.EOS: https://github.com/EOSIO/Documentation/blob/master/TechnicalWhitePaper.md
* 6.blockone: https://block.one/
* 7.JIT: https://en.wikipedia.org/wiki/Just-in-time_compilation
* 8.Merkle Tree: https://en.wikipedia.org/wiki/Merkle_tree
* 9.Message Queue: https://en.wikipedia.org/wiki/Message_queue
* 10.cosmos: https://cosmos.network/docs/resources/whitepaper.html
* 11.polkadot: https://polkadot.network/Polkadot-lightpaper.pdf
* 12.filecoin: https://filecoin.io/filecoin.pdf
* 13.BFT: https://en.wikipedia.org/wiki/Byzantine_fault_tolerance
* 14.tendermint: https://tendermint.com/docs/


[1]:https://bitcoin.org/bitcoin.pdf
[2]:https://github.com/ethereum/wiki/wiki/White-Paper
[3]:http://zerocash-project.org/paper
[4]:https://getmonero.org/
[5]:https://github.com/EOSIO/Documentation/blob/master/TechnicalWhitePaper.md
[6]:https://block.one/
[7]:https://en.wikipedia.org/wiki/Just-in-time_compilation
[8]:https://en.wikipedia.org/wiki/Merkle_tree
[9]:https://en.wikipedia.org/wiki/Message_queue
[10]:https://cosmos.network/
[11]:https://polkadot.network/#cover
[12]:https://filecoin.io/
[13]:https://en.wikipedia.org/wiki/Byzantine_fault_tolerance
[14]:https://tendermint.com/docs/

